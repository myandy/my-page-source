---
title:      "从http协议解决在线Mp4多次请求问题"
description:   "hook http协议进行内存缓存"
date:       2021-07-28 14:00:00
author:     "安地"
tags:
      - ffmpeg
      - ijkplayer
      - 音视频

---

# 问题

最近弄hls+fmp4的播放支持。发现一个mp4会请求三次，数据量会达到单个视频数据量的两倍多。

# 原因

直接原因很简单，mp4需要获取到MOOV BOX信息，读取头后需要seek到Moov位置，第三次需要seek到视频位置
解决办法也很简单，一个ffmpeg命令即可解决：
ffmpeg -i input.mp4 -movflags faststart -acodec copy -vcodec copy out.mp4
参考了这里https://www.zhangxinxu.com/wordpress/2018/12/video-moov-box/


那如果视频我们没法改或者不想改的话怎么办呢？

# 进一步分析

MOOV后置视频三次请求后两次都是带range的，如果视频地址不支持range，那这个请求就直接请求不了，支持range呢又会有多次请求，不支持range还会无法seek。
其实这些都是http和tcp协议的问题，如果用file协议的视频就没有问题。

视频不能动，那是不是可以对http协议做些什么。


# http hook方案

## 确定方案

分析出mp4协议调用seek会导致http进行重新请求，那我们不调用seek不就可以了吗。
因为http协议没有把全部数据保存下来，只有buffer保存当前获取的数据。
所以可以hook住http协议，直接把全部数据保存到内存，seek时做一个假操作，read时给对应数据就可以。

## 实现

实现使用ijkplayer扩展协议方式，参考ijkhttphook,写了一个ijkhttpseekhook的协议。

定义:
```
URLProtocol ijkimp_ff_ijkhttpseekhook_protocol = {
        .name                = "ijkhttpseekhook",
        .url_open2           = ijkhttpseekhook_open,
        .url_read            = ijkhttpseekhook_read,
        .url_seek            = ijkhttpseekhook_seek,
        .url_close           = ijkurlhook_close,
        .priv_data_size      = sizeof(Context),
        .priv_data_class     = &ijkhttpseekhook_context_class,
};
```

打开时进行协议替换，增加了一个crypto的加密协议，这个是hls中用到的。

```
static int ijkhttpseekhook_open(URLContext *h, const char *arg, int flags, AVDictionary **options) {
    Context *c = h->priv_data;
    int ret = 0;

    c->app_ctx = (AVApplicationContext *) (intptr_t) c->app_ctx_intptr;
    c->scheme = "ijkhttpseekhook:";
    if (av_stristart(arg, "ijkhttpseekhook:crypto+", NULL))
        c->inner_scheme = "crypto";
    else if (av_stristart(arg, "ijkhttpseekhook:https:", NULL))
        c->inner_scheme = "https:";
    else
        c->inner_scheme = "http:";

    ret = ijkurlhook_init(h, arg, flags, options);
    if (ret)
        goto fail;

    ret = ijkurlhook_call_inject(h);
    if (ret)
        goto fail;

    ret = ijkurlhook_reconnect(h, NULL);

    fail:
    return ret;
}
```

连接时的方法，先请求内部协议，然后获取数据长度，初始化data，再用ffurl_read读取数据。因为http有chunksize，一次不能全部获取，多次请求到全部数据。这里的read_total可能会小于logical_size，不知道是什么原因。

```
static int ijkurlhook_reconnect(URLContext *h, AVDictionary *extra) {
    Context *c = h->priv_data;
    int ret = 0;
    URLContext *new_url = NULL;
    AVDictionary *inner_options = NULL;

    assert(c->inner_options);
    av_dict_copy(&inner_options, c->inner_options, 0);
    if (extra)
        av_dict_copy(&inner_options, extra, 0);

    ret = ffurl_open_whitelist(&new_url,
                               c->app_io_ctrl.url,
                               c->inner_flags,
                               &h->interrupt_callback,
                               &inner_options,
                               h->protocol_whitelist,
                               h->protocol_blacklist,
                               h);
    if (ret)
        goto fail;

    ffurl_closep(&c->inner);

    c->inner = new_url;
    h->is_streamed = c->inner->is_streamed;
    c->logical_pos = ffurl_seek(c->inner, 0, SEEK_CUR);
    if (c->inner->is_streamed)
        c->logical_size = -1;
    else
        c->logical_size = ffurl_seek(c->inner, 0, AVSEEK_SIZE);

    c->data = av_malloc(c->logical_size);
    int read;
    int read_total = 0;
    while (read = ffurl_read(c->inner, c->data + read_total, c->logical_size) > 0) {
        read_total += read;
    }
    if (read < 0) {
        goto fail;
    }
    c->io_error = 0;
    fail:
    av_dict_free(&inner_options);
    return ret;
}
```


seek代码很简单，需要seek时把logical_pos设置为pos就可以


```
static int64_t ijkhttpseekhook_seek(URLContext *h, int64_t pos, int whence) {
    Context *c = h->priv_data;
    int ret;
    if (whence == AVSEEK_SIZE)
        return c->logical_size;
    else if ((whence == SEEK_CUR && pos == 0) ||
             (whence == SEEK_SET && pos == c->logical_pos))
        return c->logical_pos;
    else if ((c->logical_size < 0 && whence == SEEK_END) || h->is_streamed)
        return AVERROR(ENOSYS);

    if (pos <= c->logical_size) {
        c->logical_pos = pos;
        ret = pos;
    } else {
        ret = AVERROR_EXIT;
        goto fail;
    }
    return ret;
    fail:
    return ret;
}
```


read就变成了从data直接读取数据
```
static int ijkhttpseekhook_read(URLContext *h, unsigned char *buf, int size) {
    Context *c = h->priv_data;
    int ret = size;
    int remain = c->logical_size - c->logical_pos;
    if (size > remain) {
        ret = remain;
    }
    memcpy(buf, c->data + c->logical_pos, ret);
    c->logical_pos += ret;
    fail:
    if (ret <= 0) {
        c->io_error = ret;
    }
    return ret;
}
```

## 协议注册

我使用IJK_REGISTER_PROTOCOL(ijkhttpseekhook);
却发现一直编译不通过，后面才知道这这种方法被ffmpeg禁止了，只能注册DEMUXER。之前弄过注册解码器，也是只能在ffmpeg里面注册。

使用ijkffmpeg的版本，在ijkutils.c和protocols.c添加好协议占位，然后就能跑通了。

## 支持流动数据

如果http协议是is_streamed，即为流动的，就不支持seek，获取到的logical_size为-1，用前面的代码就有问题。
其实用这种方案也可以改成支持seek版本，关键是初始化时数据大小动态增长就可以，我最新版本已经支持了is_streamed的seek，这里就不具体介绍了。

## 方案总结

ijkhttpseekhook实际就是http的内存缓存，适合于小请求，防止需要seek导致的多次请求问题。


# 心路历程总结

这次介绍整体很简单，实际上却是碰了很多次壁找到了办法，也不知道这种方案会不会有什么坑，我也是第一次弄ffmpeg协议相关的东西。
最开始我想到的办法实际是使用ijkplayer的iocache,但发现有两个问题，一个是缓存路径必须一一对应，如果同一个视频网络地址名称一直在变化，那就用不了了，另一个是当前这次请求如果没有缓存文件，那这次还是会请求多次。
然后就只能去看http协议流程，看了很久代码才看懂流程，其调用走的内部tcp协议，而且都是小块缓存读取数据。然后结合ijkplayer hook协议的流程确定了方案，剩下的实现就半天搞定了。




